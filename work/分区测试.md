= 测试目的 =
 通过测试[http://10.0.0.64/wiki/index.php/Mysql相关操作#mysql分区表 mysql分区表]技术研究通话记录在大数据量（几百万或上千万数据）的分区解决方案
= 测试环境 =
 虚拟机：10.0.0.34
 数据：河南现网数据（近400万）
       mysql> select count(*) from talk_call_record;
       +----------+
       | count(*) |
       +----------+
       |  3927408 |
       +----------+
       1 row in set (0.00 sec)

= 测试步骤 =
== 分析数据 ==
* 最大时间
  mysql> select max(start_time),from_unixtime(max(start_time)) from talk_call_record;
  +-----------------+--------------------------------+
  | max(start_time) | from_unixtime(max(start_time)) |
  +-----------------+--------------------------------+
  |      1486661627 | 2017-02-10 01:33:47            |
  +-----------------+--------------------------------+
  1 row in set (0.00 sec)
* 最小时间
  mysql> select min(start_time),from_unixtime(min(start_time)) from talk_call_record;
  +-----------------+--------------------------------+
  | min(start_time) | from_unixtime(min(start_time)) |
  +-----------------+--------------------------------+
  |      1457490797 | 2016-03-09 10:33:17            |
  +-----------------+--------------------------------+
  1 row in set (0.02 sec)
* 过滤通话记录条数大于10万的企业
  mysql> select * from (select eid,count(id) as countid from talk_call_record group by eid) tb where tb.countid>100000;
  +------+---------+
  | eid  | countid |
  +------+---------+
  |  101 |  178646 |
  |  150 |  106054 |
  |  277 |  165704 |
  |  745 |  128331 |
  |  997 | 1262307 |
  +------+---------+
  5 rows in set (2.48 sec)
* 分区原则
  1、分区的目的是尽量根据业务需求平均分配数据记录，大表变小表，提高数据库效率。
  2、基于时间分区，主要考虑通话记录表是每天固定增长，按时间分区会平均分配记录到小表中
  3、基于企业id分区，目前大多数业务需求是基于eid来做过滤的，能快速定位到小表中

== mysql分区类型 ==
  mysql要求分区字段必须是主键，下面我们简单测试一下mysql的分区,由于我们打算使用eid和start_time作为分区条件，而又不改变原表结构，所有表都只建立三个字段id，eid，start_time
  SHOW VARIABLES LIKE '%partition%'; //查看是否支持分区

  '2016-01-01' 1451577600 
  '2016-02-01' 1454256000 
  '2016-03-01' 1456761600 
  '2016-04-01' 1459440000 
  '2016-05-01' 1462032000 
  '2016-06-01' 1464710400 
  '2016-07-01' 1467302400 
  '2016-08-01' 1469980800 
  '2016-09-01' 1472659200 
  '2016-10-01' 1475251200 
  '2016-11-01' 1477929600 
  '2016-12-01' 1480521600 
  2017-01-01   1483200000
  2017-02-01   1485878400
  2017-03-01   1488297600
  2017-04-01   1490976000
=== range ===
  drop table talk_range;
  create table talk_range(
    id int(10) unsigned NOT NULL AUTO_INCREMENT,
    eid int(10) unsigned DEFAULT '0',
    start_time int(11) unsigned default 0,
    primary key(id,eid,start_time),
    index idx_eid(eid),
    index idx_start_time(start_time)
  )engine myisam partition by range columns(start_time)(
     partition p20160101 values less than (1451577600),
     partition p20160201 values less than (1454256000),
     partition p666 values less than maxvalue
  );
  插入记录
  insert into talk_range(eid,start_time) values(1,1451588888);
  insert into talk_range(eid,start_time) values(2,1451599999);
  insert into talk_range(eid,start_time) values(2,1454256011);
  insert into talk_range(eid,start_time) values(2,1480521600);
  查看分区表里的记录数（myisam比较准确，innodb是近似值）
  SELECT partition_name part,partition_expression expr,partition_description descr,table_rows  FROM INFORMATION_SCHEMA.partitions WHERE TABLE_SCHEMA = schema()  AND TABLE_NAME='talk_range';  
  +-----------+--------------+------------+------------+
  | part      | expr         | descr      | table_rows |
  +-----------+--------------+------------+------------+
  | p20160101 | `start_time` | 1451577600 |          0 |
  | p20160201 | `start_time` | 1454256000 |          2 |
  | p666      | `start_time` | MAXVALUE   |          2 |
  +-----------+--------------+------------+------------+
  查看查找结果
  mysql> explain partitions select * from talk_range where eid=1;
  +----+-------------+------------+--------------------------+------+---------------+---------+---------+-------+------+-------+
  | id | select_type | table      | partitions               | type | possible_keys | key     | key_len | ref   | rows | Extra |
  +----+-------------+------------+--------------------------+------+---------------+---------+---------+-------+------+-------+
  |  1 | SIMPLE      | talk_range | p20160101,p20160201,p666 | ref  | idx_eid       | idx_eid | 4       | const |    4 |       |
  +----+-------------+------------+--------------------------+------+---------------+---------+---------+-------+------+-------+
  1 row in set (0.00 sec)
  eid不是分区条件，所以搜索所有分区
  mysql> explain partitions select * from talk_range where start_time<1451577600;
  +----+-------------+-------+------------+------+---------------+------+---------+------+------+-----------------------------------------------------+
  | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | Extra                                               |
  +----+-------------+-------+------------+------+---------------+------+---------+------+------+-----------------------------------------------------+
  |  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | Impossible WHERE noticed after reading const tables |
  +----+-------------+-------+------------+------+---------------+------+---------+------+------+-----------------------------------------------------+
  1 row in set (0.00 sec)
  由于小于1451577600分区表没有数据，返回Impossible WHERE noticed after reading const tables（表示没有可能返回数据）
  mysql> explain partitions select * from talk_range where start_time>1451577600;
  +----+-------------+------------+----------------+-------+----------------+---------+---------+------+------+--------------------------+
  | id | select_type | table      | partitions     | type  | possible_keys  | key     | key_len | ref  | rows | Extra                    |
  +----+-------------+------------+----------------+-------+----------------+---------+---------+------+------+--------------------------+
  |  1 | SIMPLE      | talk_range | p20160201,p666 | index | idx_start_time | PRIMARY | 12      | NULL |    4 | Using where; Using index |
  +----+-------------+------------+----------------+-------+----------------+---------+---------+------+------+--------------------------+
  1 row in set (0.00 sec)
  大于1451577600的分区有两个
  mysql> explain partitions select * from talk_range where start_time>1451577600 and start_time<1454256000;
  +----+-------------+------------+------------+-------+----------------+---------+---------+------+------+--------------------------+
  | id | select_type | table      | partitions | type  | possible_keys  | key     | key_len | ref  | rows | Extra                    |
  +----+-------------+------------+------------+-------+----------------+---------+---------+------+------+--------------------------+
  |  1 | SIMPLE      | talk_range | p20160201  | index | idx_start_time | PRIMARY | 12      | NULL |    2 | Using where; Using index |
  +----+-------------+------------+------------+-------+----------------+---------+---------+------+------+--------------------------+
  1 row in set (0.00 sec)
  准确定位到p20160201分区

=== list ===
  drop table talk_list;
  create table talk_list(
    id int(10) unsigned NOT NULL AUTO_INCREMENT,
    eid int(10) unsigned DEFAULT '0',
    start_time int(11) unsigned default 0,
    primary key(id,eid,start_time),
    index idx_eid(eid),
    index idx_start_time(start_time)
  )engine myisam partition by list columns(eid)(
     partition pbigep values in (1),
     partition psmallep values in (2,3,4,5)
  );
  插入记录
  insert into talk_list(eid,start_time) values(1,1451588888);
  insert into talk_list(eid,start_time) values(2,1451599999);
  insert into talk_list(eid,start_time) values(3,1454256011);
  insert into talk_list(eid,start_time) values(4,1480521600);
  insert into talk_list(eid,start_time) values(5,1480521600);
  要点：如果试图插入列值（或分区表达式的返回值）不在分区值列表中的一行时，那么“INSERT”查询将失败并报错。
  mysql> SELECT partition_name part,partition_expression expr,partition_description descr,table_rows  FROM INFORMATION_SCHEMA.partitions WHERE TABLE_SCHEMA = schema()  AND TABLE_NAME='talk_list';
  +----------+-------+---------+------------+
  | part     | expr  | descr   | table_rows |
  +----------+-------+---------+------------+
  | pbigep   | `eid` | 1       |          1 |
  | psmallep | `eid` | 2,3,4,5 |          4 |
  +----------+-------+---------+------------+
  2 rows in set (0.00 sec)
  
=== hash ===
  drop table talk_hash;
  create table talk_hash(
    id int(10) unsigned NOT NULL AUTO_INCREMENT,
    eid int(10) unsigned DEFAULT '0',
    start_time int(11) unsigned default 0,
    primary key(id,eid,start_time),
    index idx_eid(eid),
    index idx_start_time(start_time)
  )engine myisam partition by hash(eid) partitions 5;
  插入记录
  insert into talk_hash(eid,start_time) values(1,1451588888);
  insert into talk_hash(eid,start_time) values(2,1451599999);
  insert into talk_hash(eid,start_time) values(3,1454256011);
  insert into talk_hash(eid,start_time) values(4,1480521600);
  insert into talk_hash(eid,start_time) values(5,1480521600);
  insert into talk_hash(eid,start_time) values(6,1480521600);
  mysql> SELECT partition_name part,partition_expression expr,partition_description descr,table_rows  FROM INFORMATION_SCHEMA.partitions WHERE TABLE_SCHEMA = schema()  AND TABLE_NAME='talk_hash';
  +------+------+-------+------------+
  | part | expr | descr | table_rows |
  +------+------+-------+------------+
  | p0   | eid  | NULL  |          1 |
  | p1   | eid  | NULL  |          2 |
  | p2   | eid  | NULL  |          1 |
  | p3   | eid  | NULL  |          1 |
  | p4   | eid  | NULL  |          1 |
  +------+------+-------+------------+
  5 rows in set (0.00 sec)
  当使用了“PARTITION BY HASH”时，MySQL将基于用户函数结果的模数来确定使用哪个编号的分区。换句话，对于一个表达式“expr”，将要保存记录的分区编号为N ，其中“N = MOD(expr, num)”。

=== key ===
  按照KEY进行分区类似于按照HASH分区，除了HASH分区使用的用户定义的表达式，而KEY分区的 哈希函数是由MySQL 服务器提供。MySQL 簇（Cluster）使用函数MD5()来实现KEY分区；对于使用其他存储引擎的表，服务器使用其自己内部的 哈希函数，这些函数是基于与PASSWORD()一样的运算法则。
  drop table talk_key;
  create table talk_key(
    id int(10) unsigned NOT NULL AUTO_INCREMENT,
    eid int(10) unsigned DEFAULT '0',
    start_time int(11) unsigned default 0,
    primary key(id,eid,start_time),
    index idx_eid(eid),
    index idx_start_time(start_time)
  )engine myisam partition by key(eid) partitions 5;
  插入记录
  insert into talk_key(eid,start_time) values(1,1451588888);
  insert into talk_key(eid,start_time) values(2,1451599999);
  insert into talk_key(eid,start_time) values(3,1454256011);
  insert into talk_key(eid,start_time) values(4,1480521600);
  insert into talk_key(eid,start_time) values(5,1480521600);
  insert into talk_key(eid,start_time) values(6,1480521600);
  mysql> SELECT partition_name part,partition_expression expr,partition_description descr,table_rows  FROM INFORMATION_SCHEMA.partitions WHERE TABLE_SCHEMA = schema()  AND TABLE_NAME='talk_key';
  +------+-------+-------+------------+
  | part | expr  | descr | table_rows |
  +------+-------+-------+------------+
  | p0   | `eid` | NULL  |          0 |
  | p1   | `eid` | NULL  |          3 |
  | p2   | `eid` | NULL  |          0 |
  | p3   | `eid` | NULL  |          0 |
  | p4   | `eid` | NULL  |          3 |
  +------+-------+-------+------------+
  5 rows in set (0.00 sec)
  在KEY分区中使用关键字LINEAR和在HASH分区中使用具有同样的作用，分区的编号是通过2的幂（powers-of-two）算法得到，而不是通过模数算法。关于该算法及其蕴涵式的描述请参考 18.2.3.1节，“LINEAR HASH分区” 。 
  假设一个表达式expr, 当使用线性哈希功能时，记录将要保存到的分区是num 个分区中的分区N，其中N是根据下面的算法得到： 
  1. 找到下一个大于num.的、2的幂，我们把这个值称为V ，它可以通过下面的公式得到： 
  2. V = POWER(2, CEILING(LOG(2, num)))（例如，假定num是13。那么LOG(2,13)就是3.7004397181411。 CEILING(3.7004397181411)就是4，则V = POWER(2,4), 即等于16）。 
  3. 设置 N = F(column_list) & (V - 1). 
  4. 当 N >= num: 
     设置 V = CEIL(V / 2) 
     设置 N = N & (V - 1) 
  例如，假设表t1，使用线性哈希分区且有4个分区，是通过下面的语句创建的：
  CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATE)
    PARTITION BY LINEAR HASH( YEAR(col3) )
    PARTITIONS 6;
  现在假设要插入两行记录到表t1中，其中一条记录col3列值为'2003-04-14'，另一条记录col3列值为'1998-10-19'。第一条记录将要保存到的分区确定如下：
  V = POWER(2, CEILING(LOG(2,7))) = 8
  N = YEAR('2003-04-14') & (8 - 1)
   = 2003 & 7
   = 3 
  (3 >= 6 为假（FALSE）: 记录将被保存到#3号分区中)
  第二条记录将要保存到的分区序号计算如下： 
  V = 8
  N = YEAR('1998-10-19') & (8-1)
  = 1998 & 7
  = 6
 (6 >= 4 为真（TRUE）: 还需要附加的步骤)
  N = 6 & CEILING(5 / 2)
  = 6 & 3
  = 2
 (2 >= 4 为假（FALSE）: 记录将被保存到#2分区中)
 按照线性哈希分区的优点在于增加、删除、合并和拆分分区将变得更加快捷，有利于处理含有极其大量（1000吉）数据的表。它的缺点在于，与使用常规HASH分区得到的数据分布相比，各个分区间数据的分布不大可能均衡。

=== 子分区 ===
  mysql允许RANGE和LIST分区上再进行HASH和KEY的子分区
  先按日期range分区，再按eid做hash分区
  drop table talk_range_hash;
  create table talk_range_hash(
    id int(10) unsigned NOT NULL AUTO_INCREMENT,
    eid int(10) unsigned DEFAULT '0',
    start_time int(11) unsigned default 0,
    primary key(id,eid,start_time),
    index idx_eid(eid),
    index idx_start_time(start_time)
  )engine myisam partition by range columns(start_time) subpartition by hash(eid) subpartitions 5(
    partition p20160101 values less than (1451577600),
    partition p20160201 values less than (1454256000),
    partition p666 values less than maxvalue
  );
  插入记录
  insert into talk_range_hash(eid,start_time) values(1,1451588888);
  insert into talk_range_hash(eid,start_time) values(2,1451599999);
  insert into talk_range_hash(eid,start_time) values(3,1454256011);
  insert into talk_range_hash(eid,start_time) values(4,1480521600);
  insert into talk_range_hash(eid,start_time) values(5,1480521600);
  insert into talk_range_hash(eid,start_time) values(6,1480521600);
  mysql> SELECT partition_name part,partition_expression expr,partition_description descr,table_rows  FROM INFORMATION_SCHEMA.partitions WHERE TABLE_SCHEMA = schema()  AND TABLE_NAME='talk_range_hash';
  +-----------+--------------+------------+------------+
  | part      | expr         | descr      | table_rows |
  +-----------+--------------+------------+------------+
  | p20160101 | `start_time` | 1451577600 |          0 |
  | p20160101 | `start_time` | 1451577600 |          0 |
  | p20160101 | `start_time` | 1451577600 |          0 |
  | p20160101 | `start_time` | 1451577600 |          0 |
  | p20160101 | `start_time` | 1451577600 |          0 |
  | p20160201 | `start_time` | 1454256000 |          0 |
  | p20160201 | `start_time` | 1454256000 |          1 |
  | p20160201 | `start_time` | 1454256000 |          1 |
  | p20160201 | `start_time` | 1454256000 |          0 |
  | p20160201 | `start_time` | 1454256000 |          0 |
  | p666      | `start_time` | MAXVALUE   |          1 |
  | p666      | `start_time` | MAXVALUE   |          1 |
  | p666      | `start_time` | MAXVALUE   |          0 |
  | p666      | `start_time` | MAXVALUE   |          1 |
  | p666      | `start_time` | MAXVALUE   |          1 |
  +-----------+--------------+------------+------------+
  15 rows in set (0.00 sec)

=== 运维需求简单测试 ===
  基于以上分析，目前暂定方案是保留12个月分区，每个月分区里按eid做hash分配通话记录，那么在每月需要加一个月分区，比如三月一日加一个分区，将去年的老分区删除或移动到历史记录中，可以使用一下命令
  alter table talk_range_hash drop partition p20160101; 
  要点：对于通过RANGE分区的表，只可以使用ADD PARTITION添加新的分区到分区列表的高端。设法通过这种方式在现有分区的前面或之间增加一个新的分区，将会导致下面的一个错误：
  alter table talk_range_hash add partition (partition p20160301 values less than (1456761600));
  错误1463 (HY000): 对每个分区，VALUES LESS THAN 值必须严格增长
  ALTER TABLE talk_range_hash REORGANIZE PARTITION p666 INTO (
    PARTITION p20160301 VALUES LESS THAN (1456761600),
    PARTITION p666 VALUES LESS THAN maxvalue
  );
  还有一种情况是基于现有数据进行分区，先创建不分区的表，再分区（不丢失数据）
  drop table talk_range_hash;
  create table talk_range_hash(
   id int(10) unsigned NOT NULL AUTO_INCREMENT,
   eid int(10) unsigned DEFAULT '0',
   start_time int(11) unsigned default 0,
   primary key(id,eid,start_time),
   index idx_eid(eid),
   index idx_start_time(start_time)
  )engine myisam;
  插入记录
  insert into talk_range_hash(eid,start_time) values(1,1451588888);
  insert into talk_range_hash(eid,start_time) values(2,1451599999);
  insert into talk_range_hash(eid,start_time) values(3,1454256011);
  insert into talk_range_hash(eid,start_time) values(4,1480521600);
  insert into talk_range_hash(eid,start_time) values(5,1480521600);
  insert into talk_range_hash(eid,start_time) values(6,1480521600);
  添加分区，如果要重新设置分区也可以采用这个命令，比如从range变更为hash
  alter table talk_range_hash partition by range columns(start_time) subpartition by hash(eid) subpartitions 5(
   partition p20160101 values less than (1451577600),
   partition p20160201 values less than (1454256000),
   partition p666 values less than maxvalue
  );

== 现网数据测试 ==
 基于以上测试，我们回归到基于现网数据的talk_call_record表分区性能测试，测试过程中创建基于引擎myisam的talk_call_record表。使用以下测试语句
 A、通话记录查询
{| border="1" cellspacing="0" cellpadding="5"
 |-
 ! sql语句
 |-
 |select count(*) from `talk_call_record` WHERE ( `eid` = '997' ) AND ( (`start_time` > 1480585500) AND (`start_time` < 1489485000)  );
 |-
 |SELECT `id`,`eid`,`call_type`,`dialing`,`dialing_member`,`incoming`,`incoming_member`,`start_time`,`duration_time`,`duration_minute`,`call_state`,`pub_number`,`outside_type`,`outnumber` FROM `talk_call_record` WHERE ( `eid` = '997' ) AND ( (`start_time` > 1480585500) AND (`start_time` < 1489485000)  ) ORDER BY start_time desc,cc_number LIMIT 0,20 ;
 |-
 |SELECT `id`,`eid`,`call_type`,`dialing`,`dialing_member`,`incoming`,`incoming_member`,`start_time`,`duration_time`,`duration_minute`,`call_state`,`pub_number`,`outside_type`,`outnumber` FROM `talk_call_record` WHERE ( `eid` = '997' ) AND ( (`start_time` > 1480585500) AND (`start_time` < 1489485000)  ) ORDER BY start_time desc,cc_number LIMIT 10000,20 ;
 |-
 |SELECT count(*) FROM `talk_call_record` WHERE ( `eid` = '997' ) AND ( (`start_time` > 1483200000) AND (`start_time` < 1485878400)  ) ;
 |-
 |SELECT `id`,`eid`,`call_type`,`dialing`,`dialing_member`,`incoming`,`incoming_member`,`start_time`,`duration_time`,`duration_minute`,`call_state`,`pub_number`,`outside_type`,`outnumber` FROM `talk_call_record` WHERE ( `eid` = '997' ) AND ( (`start_time` > 1483200000) AND (`start_time` < 1485878400)  ) ORDER BY start_time desc,cc_number LIMIT 0,20 ;
 |-
 |SELECT `id`,`eid`,`call_type`,`dialing`,`dialing_member`,`incoming`,`incoming_member`,`start_time`,`duration_time`,`duration_minute`,`call_state`,`pub_number`,`outside_type`,`outnumber` FROM `talk_call_record` WHERE ( `eid` = '997' ) AND ( (`start_time` > 1483200000) AND (`start_time` < 1485878400)  ) ORDER BY start_time desc,cc_number LIMIT 10000,20 ;
  |-
 |SELECT `id`,`eid`,`call_type`,`dialing`,`dialing_member`,`incoming`,`incoming_member`,`start_time`,`duration_time`,`duration_minute`,`call_state`,`pub_number`,`outside_type`,`outnumber` FROM `talk_call_record` WHERE ( `eid` = '997' ) AND ( (`start_time` > 1483200000) AND (`start_time` < 1485878400)  ) ORDER BY start_time desc LIMIT 0,20 ;
 |-
 |SELECT `id`,`eid`,`call_type`,`dialing`,`dialing_member`,`incoming`,`incoming_member`,`start_time`,`duration_time`,`duration_minute`,`call_state`,`pub_number`,`outside_type`,`outnumber` FROM `talk_call_record` WHERE ( `eid` = '997' ) AND ( (`start_time` > 1483200000) AND (`start_time` < 1485878400)  ) ORDER BY start_time desc LIMIT 10000,20 ;
 |}
 B、慢查询
 {| border="1" cellspacing="0" cellpadding="5"
 |-
 ! sql语句
 |-
 |select count(*) from talk_call_record where eid=997 and (dialing like '%964823184%' or incoming like '%964823184%') and res_token <> "" ;
 |-
 |select id,call_type,dialing,incoming,start_time,duration_time from talk_call_record where eid=997 and (dialing like '%964823184%' or incoming like '%964823184%') and res_token <> "" order by  start_time desc limit 0,10;
 |-
 |SELECT `duration_time` FROM `talk_call_record` WHERE ( `res_token` = 'd61318963b483e35aa693a6866923c211486650919' ) LIMIT 1;
 |-
 |SELECT sum(duration_time) as stime,sum(duration_minute) as sminute,`outside_type` FROM `talk_call_record` WHERE ( `eid` = '997' ) GROUP BY outside_type;
 |-
 |select max(id) from talk_sync where eid=997 limit 1;
 |}
 C、

* 测试结果
 {| border="1" cellspacing="0" cellpadding="5"
 |-
 ! style="width:10%" | 建库语句
 ! style="width:10%" | A
 ! style="width:10%" | B
 ! style="width:10%" | C
 ! style="width:10%" | D
 ! style="width:50%" | 说明
 |- 
 | 现网库
 | 
  count(*) 1262307 1 row in set (1.34 sec)
  20 rows in set (3.38 sec)
  20 rows in set (30.45 sec)
  count(*) 857347 1 row in set (1.52 sec)
  20 rows in set (2.30 sec)
  20 rows in set (14.34 sec)
  去掉一个排序条件
  20 rows in set (0.02 sec)
  20 rows in set (0.16 sec)
 | 
  count(*)  0 1 row in set (2.27 sec)
  Empty set (18.45 sec)
  1 row in set (1.79 sec)
  2 rows in set (1.83 sec)
 | 
 | 
 | 
 |- 
 | 
 drop table if exists talk_call_record_myisam_idx;
  CREATE TABLE if not exists `talk_call_record_myisam_idx` (
 `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
 `eid` int(10) unsigned DEFAULT '0',
 `call_type` tinyint(2) DEFAULT '0' COMMENT '通话方式,0两方通话1三方2会议',
 `dialing` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '主叫',
 `dialing_member` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '主叫用户名',
 `incoming` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '被叫',
 `incoming_member` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '被叫用户名',
 `start_time` int(10) unsigned DEFAULT '0' COMMENT '开始时间',
 `end_time` int(10) unsigned DEFAULT '0' COMMENT '结束时间',
 `duration_time` int(10) unsigned DEFAULT '0' COMMENT '通话时长',
 `duration_minute` int(10) DEFAULT '0' COMMENT '通话次数60秒算一次',
 `call_state` tinyint(2) DEFAULT '0' COMMENT '通话状态',
 `pub_number` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '外线帐号',
 `outnumber` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '外线号码',
 `provinc_city` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '归属地',
 `line_type` tinyint(2) DEFAULT '0' COMMENT '0内线1市话2国内长途3国际长途',
 `outside_type` tinyint(2) DEFAULT '0' COMMENT '0不是外线1呼入2呼出',
 `cc_number` varchar(128) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '频道号',
 `event_str` text CHARACTER SET utf8 NOT NULL COMMENT '通话事件描述',
 `event_name` varchar(128) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '通话事件名称',
 `res_token` varchar(128) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '录音文件唯一id',
 `record_status` tinyint(2) NOT NULL DEFAULT '0' COMMENT '录音状态0未录音1等待上传2上传中3上传成功',
 `record_filename` varchar(512) COLLATE utf8_unicode_ci NOT NULL DEFAULT ''  COMMENT '录音文件名',
 PRIMARY KEY (`id`),
 key cridx_eid_start_time(eid,start_time),
 KEY `cridx_cc_number` (`cc_number`),
 KEY `cridx_eid` (`eid`),
 KEY `cridx_start_time` (`start_time`)
 ) ENGINE=MyISAM;
 insert into talk_call_record_myisam_idx select * from talk_call_record;
 | 
 count(*) 1262307 1 row in set (0.41 sec)
 20 rows in set (3.32 sec)
 20 rows in set (25.74 sec)
 count(*) 857347 1 row in set (0.28 sec)
 20 rows in set (3.10 sec)
 20 rows in set (18.80 sec)
 | 
  res_token加索引后 1 row in set (0.01 sec)
 | 
 | 
 | 现网库加索引
 |- 
 | 
  drop table if exists talk_call_record_myisam_month;
  CREATE TABLE if not exists `talk_call_record_myisam_month` (
 `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
 `eid` int(10) unsigned DEFAULT '0',
 `call_type` tinyint(2) DEFAULT '0' COMMENT '通话方式,0两方通话1三方2会议',
 `dialing` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '主叫',
 `dialing_member` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '主叫用户名',
 `incoming` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '被叫',
 `incoming_member` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '被叫用户名',
 `start_time` int(10) unsigned DEFAULT '0' COMMENT '开始时间',
 `end_time` int(10) unsigned DEFAULT '0' COMMENT '结束时间',
 `duration_time` int(10) unsigned DEFAULT '0' COMMENT '通话时长',
 `duration_minute` int(10) DEFAULT '0' COMMENT '通话次数60秒算一次',
 `call_state` tinyint(2) DEFAULT '0' COMMENT '通话状态',
 `pub_number` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '外线帐号',
 `outnumber` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '外线号码',
 `provinc_city` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '归属地',
 `line_type` tinyint(2) DEFAULT '0' COMMENT '0内线1市话2国内长途3国际长途',
 `outside_type` tinyint(2) DEFAULT '0' COMMENT '0不是外线1呼入2呼出',
 `cc_number` varchar(128) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '频道号',
 `event_str` text CHARACTER SET utf8 NOT NULL COMMENT '通话事件描述',
 `event_name` varchar(128) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '通话事件名称',
 `res_token` varchar(128) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '录音文件唯一id',
 `record_status` tinyint(2) NOT NULL DEFAULT '0' COMMENT '录音状态0未录音1等待上传2上传中3上传成功',
 `record_filename` varchar(512) COLLATE utf8_unicode_ci NOT NULL DEFAULT ''  COMMENT '录音文件名',
 PRIMARY KEY (`id`,eid,start_time),
 KEY `cridx_cc_number` (`cc_number`),
 KEY `cridx_eid` (`eid`),
 KEY `cridx_start_time` (`start_time`)
 ) ENGINE=MyISAM PARTITION BY RANGE (`start_time`) (
       PARTITION p20160401 VALUES LESS THAN (1459440000),
       PARTITION p20160501 VALUES LESS THAN (1462032000), 
       PARTITION p20160601 VALUES LESS THAN (1464710400),
       PARTITION p20160701 VALUES LESS THAN (1467302400),
       PARTITION p20160801 VALUES LESS THAN (1469980800),
       PARTITION p20160901 VALUES LESS THAN (1472659200),
       PARTITION p20161001 VALUES LESS THAN (1475251200),
       PARTITION p20161101 VALUES LESS THAN (1477929600),
       PARTITION p20161201 VALUES LESS THAN (1480521600),
       PARTITION p20170101 VALUES LESS THAN (1483200000),
       PARTITION p20170201 VALUES LESS THAN (1485878400),
       PARTITION p20170301 VALUES LESS THAN (1488297600),
       PARTITION p20170401 VALUES LESS THAN (1490976000),
       PARTITION p666 VALUES LESS THAN MAXVALUE 
 );
 insert into talk_call_record_myisam_month select * from talk_call_record;
 | 
 count(*) 1262307 1 row in set (2.03 sec)
 20 rows in set (3.28 sec)
 20 rows in set (23.34 sec)
 count(*) 857347 1 row in set (1.10 sec)
 20 rows in set (1.82 sec)
 20 rows in set (21.26 sec)
 | 
 | 
 | 
 | 每月分区
 |- 
 | 
  drop table if exists talk_call_record_myisam_month_eid;
  CREATE TABLE if not exists `talk_call_record_myisam_month_eid` (
 `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
 `eid` int(10) unsigned DEFAULT '0',
 `call_type` tinyint(2) DEFAULT '0' COMMENT '通话方式,0两方通话1三方2会议',
 `dialing` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '主叫',
 `dialing_member` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '主叫用户名',
 `incoming` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '被叫',
 `incoming_member` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '被叫用户名',
 `start_time` int(10) unsigned DEFAULT '0' COMMENT '开始时间',
 `end_time` int(10) unsigned DEFAULT '0' COMMENT '结束时间',
 `duration_time` int(10) unsigned DEFAULT '0' COMMENT '通话时长',
 `duration_minute` int(10) DEFAULT '0' COMMENT '通话次数60秒算一次',
 `call_state` tinyint(2) DEFAULT '0' COMMENT '通话状态',
 `pub_number` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '外线帐号',
 `outnumber` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '外线号码',
 `provinc_city` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '归属地',
 `line_type` tinyint(2) DEFAULT '0' COMMENT '0内线1市话2国内长途3国际长途',
 `outside_type` tinyint(2) DEFAULT '0' COMMENT '0不是外线1呼入2呼出',
 `cc_number` varchar(128) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '频道号',
 `event_str` text CHARACTER SET utf8 NOT NULL COMMENT '通话事件描述',
 `event_name` varchar(128) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '通话事件名称',
 `res_token` varchar(128) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '录音文件唯一id',
 `record_status` tinyint(2) NOT NULL DEFAULT '0' COMMENT '录音状态0未录音1等待上传2上传中3上传成功',
 `record_filename` varchar(512) COLLATE utf8_unicode_ci NOT NULL DEFAULT ''  COMMENT '录音文件名',
 PRIMARY KEY (`id`,eid,start_time),
 KEY `cridx_cc_number` (`cc_number`),
 KEY `cridx_eid` (`eid`),
 KEY `cridx_start_time` (`start_time`)
 ) ENGINE=MyISAM PARTITION BY RANGE (`start_time`) subpartition by hash(eid) subpartitions 10(
       PARTITION p20160401 VALUES LESS THAN (1459440000),
       PARTITION p20160501 VALUES LESS THAN (1462032000), 
       PARTITION p20160601 VALUES LESS THAN (1464710400),
       PARTITION p20160701 VALUES LESS THAN (1467302400),
       PARTITION p20160801 VALUES LESS THAN (1469980800),
       PARTITION p20160901 VALUES LESS THAN (1472659200),
       PARTITION p20161001 VALUES LESS THAN (1475251200),
       PARTITION p20161101 VALUES LESS THAN (1477929600),
       PARTITION p20161201 VALUES LESS THAN (1480521600),
       PARTITION p20170101 VALUES LESS THAN (1483200000),
       PARTITION p20170201 VALUES LESS THAN (1485878400),
       PARTITION p20170301 VALUES LESS THAN (1488297600),
       PARTITION p20170401 VALUES LESS THAN (1490976000),
       PARTITION p666 VALUES LESS THAN MAXVALUE 
 );
 insert into talk_call_record_myisam_month_eid select * from talk_call_record;
 | 
 count(*) 1262307 1 row in set (0.69 sec)
 20 rows in set (3.09 sec)
 20 rows in set (21.35 sec)
 count(*) 857347 1 row in set (0.35 sec)
 20 rows in set (2.02 sec)
 20 rows in set (12.85 sec)
 | 
 | 
 | 
 |  每月分区，每月当中按eid的hash值分区
 |- 
 | 
  drop table if exists talk_call_record_myisam_eid ;
  CREATE TABLE if not exists `talk_call_record_myisam_eid` (
 `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
 `eid` int(10) unsigned DEFAULT '0',
 `call_type` tinyint(2) DEFAULT '0' COMMENT '通话方式,0两方通话1三方2会议',
 `dialing` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '主叫',
 `dialing_member` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '主叫用户名',
 `incoming` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '被叫',
 `incoming_member` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '被叫用户名',
 `start_time` int(10) unsigned DEFAULT '0' COMMENT '开始时间',
 `end_time` int(10) unsigned DEFAULT '0' COMMENT '结束时间',
 `duration_time` int(10) unsigned DEFAULT '0' COMMENT '通话时长',
 `duration_minute` int(10) DEFAULT '0' COMMENT '通话次数60秒算一次',
 `call_state` tinyint(2) DEFAULT '0' COMMENT '通话状态',
 `pub_number` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '外线帐号',
 `outnumber` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '外线号码',
 `provinc_city` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '归属地',
 `line_type` tinyint(2) DEFAULT '0' COMMENT '0内线1市话2国内长途3国际长途',
 `outside_type` tinyint(2) DEFAULT '0' COMMENT '0不是外线1呼入2呼出',
 `cc_number` varchar(128) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '频道号',
 `event_str` text CHARACTER SET utf8 NOT NULL COMMENT '通话事件描述',
 `event_name` varchar(128) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '通话事件名称',
 `res_token` varchar(128) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '录音文件唯一id',
 `record_status` tinyint(2) NOT NULL DEFAULT '0' COMMENT '录音状态0未录音1等待上传2上传中3上传成功',
 `record_filename` varchar(512) COLLATE utf8_unicode_ci NOT NULL DEFAULT ''  COMMENT '录音文件名',
 PRIMARY KEY (`id`,eid,start_time),
 KEY `cridx_cc_number` (`cc_number`),
 KEY `cridx_eid` (`eid`),
 KEY `cridx_start_time` (`start_time`)
 ) ENGINE=MyISAM PARTITION BY hash(`eid`) partitions 100;
 insert into talk_call_record_myisam_eid select * from talk_call_record;
 | 
 count(*) 1262307 1 row in set (0.46 sec)
 20 rows in set (3.06 sec)
 20 rows in set (21.42 sec)
 count(*) 857347 1 row in set (0.49 sec)
 20 rows in set (2.01 sec)
 20 rows in set (16.10 sec)
 | 
 count(*) 0 1 row in set (1.14 sec)
 Empty set (3.35 sec)
 2 rows in set (1.12 sec)
 | 
 | 
 |  按eid的hash值分区
 |}

= 重点测试 =
 从现场反馈的结果看，性能问题主要出现在talk_call_record和talk_sync等大表上，测试过程也看出分区对性能提升比较明显，但必须结合查询条件做优化才能取得比较明显的效果。

== 调用talk_call_record,talk_sync的sql ==
  Cli 
   AdminAction
      uploadFileToFs
      cleanDb()
   CallAction
      exportCallRecord
   CustomerAction
      importTemplate()
      delCustomerByParams
   ContactAction
      importTemplate
   ExportRecordAction
      exportRecord
   RecordManagerAction
      deleteRecord
   IntegralStisticsAction 
      initStatistics()
         select min(start_time) min_time,max(start_time) max_time from talk_call_record where start_time>0; 1 row in set (0.00 sec) Select tables optimized away(无法优化的查询，意思是没法再快了）
   CallRecordModel
      GetCallExportRecordsToFile($conditions)
   CustomerModel
      SaveCustomer
      DeleteCustomer
   CustomerEventModel
      SearchEvents($params)
   EnterpriseModel
      CreateEp
      SyncEpInfoToMaintenance
   IntegralStisticsModel
      GetActiveMember
   MemberEventModel
      ProcessEvent
   PubAccountModel
      ReleasePubAccount
      SyncPubaccToMaintenance
   SipMemberModel(添加更新字段)
   SyncModel
 www 
   ApiAction 
      getAccessUrl
      getEpCallRecordInfo
      getCallRecordFromTalk()
         select * from talk_call_record where eid=997 and id>0 and 1=1 order by id asc limit 0,20  20 rows in set (2.05 sec)
      updateCallExtend
   CallAction
      record()
      getFileAccessUrl
   MapiAction
      json_interface
   NotifyManagerAction
      refreshCount
      retryNotify
      getCallList
      getBatchInfos
      searchNotify
      getNotify
   RecordManagerAction
      getRecordFileUrl
      deleteRecord
      deleteSelectRecord
      recordControl
      getRecordStatus
      recordInfos
   ApiAction
      getMembers
      getMembersInfo
      upgradeInfo()
      upgradeInfo
      uploadPhoto
   ContactAction
      all
      sync
   DeviceAction
   EnterpriseAction  
   MapiAction
      upgradeInfo
   CallRecordModel
      GetCallExportRecordsToFile
      getCountRecordByEid
         select count(t.counts) cnt from (select count(*) counts from talk_call_record where eid=997 and res_token<>'' group by cc_number) t;  258650条1 row in set (25.05 sec)
      SearchRecordByCondition
      getSuccessRecord 
      getInfosByCondition 
      searchFailCallInCc
      GetCallRecord       
   CustomerEventModel
      SearchEvents
   CustomerModel
   IntegralStisticsModel
      GetActiveMember
   SyncModel

== 最终表 ==
 实时表只保留三个月数据，按eid分区，由于分区采用200个（mysql表最大支持1000），理论上200以下企业时性能最好
 drop table if exists talk_call_record_myisam_eid ;
  CREATE TABLE if not exists `talk_call_record_myisam_eid` (
 `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
 `eid` int(10) unsigned DEFAULT '0',
 `call_type` tinyint(2) DEFAULT '0' COMMENT '通话方式,0两方通话1三方2会议',
 `dialing` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '主叫',
 `dialing_member` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '主叫用户名',
 `incoming` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '被叫',
 `incoming_member` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '被叫用户名',
 `start_time` int(10) unsigned DEFAULT '0' COMMENT '开始时间',
 `end_time` int(10) unsigned DEFAULT '0' COMMENT '结束时间',
 `duration_time` int(10) unsigned DEFAULT '0' COMMENT '通话时长',
 `duration_minute` int(10) DEFAULT '0' COMMENT '通话次数60秒算一次',
 `call_state` tinyint(2) DEFAULT '0' COMMENT '通话状态',
 `pub_number` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '外线帐号',
 `outnumber` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '外线号码',
 `provinc_city` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '归属地',
 `line_type` tinyint(2) DEFAULT '0' COMMENT '0内线1市话2国内长途3国际长途',
 `outside_type` tinyint(2) DEFAULT '0' COMMENT '0不是外线1呼入2呼出',
 `cc_number` varchar(128) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '频道号',
 `event_str` text CHARACTER SET utf8 NOT NULL COMMENT '通话事件描述',
 `event_name` varchar(128) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '通话事件名称',
 `res_token` varchar(128) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '录音文件唯一id',
 `record_status` tinyint(2) NOT NULL DEFAULT '0' COMMENT '录音状态0未录音1等待上传2上传中3上传成功',
 `record_filename` varchar(512) COLLATE utf8_unicode_ci NOT NULL DEFAULT ''  COMMENT '录音文件名',
 PRIMARY KEY (`id`,eid,start_time),
 KEY `cridx_cc_number` (`cc_number`),
 KEY `cridx_eid` (`eid`),
 KEY `cridx_start_time` (`start_time`)
 ) ENGINE=MyISAM PARTITION BY hash(`eid`) partitions 200;
 insert into talk_call_record_myisam_eid select * from talk_call_record where start_time>=1483200000;
 报错：ERROR 23 (HY000): Out of resources when opening file
 修改linux ulimit -n 65536
 修改my.cnf 添加open_files_limit 4096,重启mysql
 mysql> show global variables like 'Open_file%';
 +------------------+-------+
 | Variable_name    | Value |
 +------------------+-------+
 | open_files_limit | 4096  |
 +------------------+-------+
 1 row in set (0.00 sec)

 mysql> SHOW GLOBAL STATUS LIKE 'Open_files';
 +---------------+-------+
 | Variable_name | Value |
 +---------------+-------+
 | Open_files    | 1050  |
 +---------------+-------+
 1 row in set (0.02 sec)
 查询大于10万的分区表
 select PARTITION_NAME,SUBPARTITION_NAME,PARTITION_METHOD,PARTITION_EXPRESSION,PARTITION_DESCRIPTION,TABLE_ROWS from INFORMATION_SCHEMA.partitions WHERE TABLE_SCHEMA = schema()  AND TABLE_NAME='talk_call_record_myisam_eid' and TABLE_ROWS>100000;

 历史表按年分区
 drop table if exists talk_call_record_myisam_history;
  CREATE TABLE if not exists `talk_call_record_myisam_history` (
 `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
 `eid` int(10) unsigned DEFAULT '0',
 `call_type` tinyint(2) DEFAULT '0' COMMENT '通话方式,0两方通话1三方2会议',
 `dialing` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '主叫',
 `dialing_member` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '主叫用户名',
 `incoming` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '被叫',
 `incoming_member` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '被叫用户名',
 `start_time` int(10) unsigned DEFAULT '0' COMMENT '开始时间',
 `end_time` int(10) unsigned DEFAULT '0' COMMENT '结束时间',
 `duration_time` int(10) unsigned DEFAULT '0' COMMENT '通话时长',
 `duration_minute` int(10) DEFAULT '0' COMMENT '通话次数60秒算一次',
 `call_state` tinyint(2) DEFAULT '0' COMMENT '通话状态',
 `pub_number` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '外线帐号',
 `outnumber` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '外线号码',
 `provinc_city` varchar(64) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '归属地',
 `line_type` tinyint(2) DEFAULT '0' COMMENT '0内线1市话2国内长途3国际长途',
 `outside_type` tinyint(2) DEFAULT '0' COMMENT '0不是外线1呼入2呼出',
 `cc_number` varchar(128) COLLATE utf8_unicode_ci DEFAULT '0' COMMENT '频道号',
 `event_str` text CHARACTER SET utf8 NOT NULL COMMENT '通话事件描述',
 `event_name` varchar(128) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '通话事件名称',
 `res_token` varchar(128) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '录音文件唯一id',
 `record_status` tinyint(2) NOT NULL DEFAULT '0' COMMENT '录音状态0未录音1等待上传2上传中3上传成功',
 `record_filename` varchar(512) COLLATE utf8_unicode_ci NOT NULL DEFAULT ''  COMMENT '录音文件名',
 PRIMARY KEY (`id`,start_time),
 KEY `cridx_cc_number` (`cc_number`),
 KEY `cridx_eid` (`eid`),
 KEY `cridx_start_time` (`start_time`)
 ) ENGINE=MyISAM PARTITION BY RANGE (`start_time`) (
       PARTITION pbefore2016 VALUES LESS THAN (unix_timestamp('2016-01-01')),
       PARTITION p2016 VALUES LESS THAN (unix_timestamp('2017-01-01')),
       PARTITION p2017 VALUES LESS THAN (unix_timestamp('2018-01-01')),
       PARTITION p2018 VALUES LESS THAN (unix_timestamp('2019-01-01')),
       PARTITION p666 VALUES LESS THAN MAXVALUE 
 );
 insert into talk_call_record_myisam_history select * from talk_call_record where start_time<1483200000;
 select PARTITION_NAME,SUBPARTITION_NAME,PARTITION_METHOD,PARTITION_EXPRESSION,PARTITION_DESCRIPTION,TABLE_ROWS from INFORMATION_SCHEMA.partitions WHERE TABLE_SCHEMA = schema()  AND TABLE_NAME='talk_call_record_myisam_history' ;

 同步表按eid分区，定时删除一个月前的数据
 drop table if exists talk_sync_myisam_eid;
 CREATE TABLE `talk_sync_myisam_eid` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `mid` int(11) NOT NULL DEFAULT '0',
  `uid` int(11) NOT NULL DEFAULT '0',
  `gid` int(11) NOT NULL DEFAULT '0',
  `cid` int(11) NOT NULL DEFAULT '0',
  `eid` int(11) NOT NULL,
  `sync_time` int(11) unsigned NOT NULL,
  `module` tinyint(2) NOT NULL DEFAULT '1' COMMENT '1memberinfo2memberphoto3group4customer',
  `type` tinyint(2) NOT NULL DEFAULT '1' COMMENT '1create2modify3delete',
  `imei` varchar(32) COLLATE utf8_unicode_ci DEFAULT '',
  PRIMARY KEY (`id`,eid),
  KEY `syidx_eid` (`eid`)
 ) ENGINE=MyISAM PARTITION BY hash(`eid`) partitions 10;
 insert into talk_sync_myisam_eid select * from talk_sync where sync_time>=1483200000;

== 主要sql测试 ==

 {| border="1" cellspacing="0" cellpadding="5" style="table-layout:fixed;" width='100%'
 |-
 ! style="width:30%" | sql语句
 ! style="width:30%" | 结果
 ! style="width:40%" | 说明
 |-
 | style="word-wrap:break-word;word-break:break-all;overflow:hidden;" | 
   reset query cache;SELECT sum(duration_time) as stime,sum(duration_minute) as sminute,`outside_type` FROM `talk_call_record` WHERE ( `eid` = '997' ) GROUP BY outside_type;
   reset query cache;SELECT sum(duration_time) as stime,sum(duration_minute) as sminute,`outside_type` FROM `talk_call_record_myisam_eid` WHERE ( `eid` = '997' ) GROUP BY outside_type;
   reset query cache;SELECT sum(duration_time) as stime,sum(duration_minute) as sminute,`outside_type` FROM `talk_call_record_myisam_history` WHERE ( `eid` = '997' ) GROUP BY outside_type;
 | 
   现网库     2 rows in set (1.73 sec)
   分区实时库 2 rows in set (0.92 sec)
   分区历史库 2 rows in set (0.07 sec)
 |
   现网库3927408分区实时库1984450分区历史库1942958
   该语句是运维上报的多次死锁语句
 |-
 | style="word-wrap:break-word;word-break:break-all;overflow:hidden;" | 
   reset query cache;select id,call_type,dialing,incoming,start_time,duration_time from talk_call_record where eid=997 and (dialing like '%1000%' or incoming like '%1000%') and res_token <> "" order by  start_time desc limit 0,10;
   reset query cache;select id,call_type,dialing,incoming,start_time,duration_time from talk_call_record_myisam_eid where eid=997 and (dialing like '%1000%' or incoming like '%1000%') and res_token <> "" order by  start_time desc limit 0,10;
   reset query cache;select id,call_type,dialing,incoming,start_time,duration_time from talk_call_record_myisam_history where eid=997 and (dialing like '%1000%' or incoming like '%1000%') and res_token <> "" order by  start_time desc limit 0,10;
 | 
   现网库      10 rows in set (0.10 sec)
   分区实时库  10 rows in set (0.05 sec)
   分区历史库  7 rows in set (2.10 sec)
 |
   该语句是运维上报的多次死锁语句
 |-
 | style="word-wrap:break-word;word-break:break-all;overflow:hidden;" | 
   reset query cache; SELECT `duration_time` FROM `talk_call_record` WHERE ( `res_token` = '45471c6f9db76ed1dcf7ce812b600df31481163525' ) LIMIT 1;
   reset query cache; SELECT `duration_time` FROM talk_call_record_myisam_eid WHERE ( `res_token` = '45471c6f9db76ed1dcf7ce812b600df31481163525' ) LIMIT 1;
   reset query cache; SELECT `duration_time` FROM talk_call_record_myisam_history WHERE ( `res_token` = '45471c6f9db76ed1dcf7ce812b600df31481163525' ) LIMIT 1;
 | 
   现网库      1 row in set (0.49 sec)
   分区实时库  Empty set (1.01 sec)
   分区历史库  1 row in set (0.54 sec)
 |
   该语句是运维上报的多次死锁语句
 |-
 | style="word-wrap:break-word;word-break:break-all;overflow:hidden;" | 
   reset query cache; select count(*) from `talk_call_record` WHERE ( `eid` = '997' ) AND ( (`start_time` > 1480585500) AND (`start_time` < 1489485000) );
   reset query cache; SELECT count(*) FROM talk_call_record_myisam_eid WHERE ( `eid` = '997' ) AND ( (`start_time` > 1480585500) AND (`start_time` < 1489485000) );
   reset query cache; SELECT count(*) FROM talk_call_record_myisam_history WHERE ( `eid` = '997' ) AND ( (`start_time` > 1480585500) AND (`start_time` < 1489485000) );
 | 
   现网库      1 row in set (1.27 sec)
   分区实时库  1 row in set (0.43 sec)
   分区历史库  1 row in set (0.06 sec)
 |
   该语句是搜索通话记录时count语句
 |-
 | style="word-wrap:break-word;word-break:break-all;overflow:hidden;" | 
   reset query cache; SELECT `id`,`eid`,`call_type`,`dialing`,`dialing_member`,`incoming`,`incoming_member`,`start_time`,`duration_time`,`duration_minute`,`call_state`,`pub_number`,`outside_type`,`outnumber` FROM `talk_call_record` WHERE ( `eid` = '997' ) AND ( (`start_time` > 1480585500) AND (`start_time` < 1489485000) ) ORDER BY start_time desc,cc_number LIMIT 0,20 ;
   reset query cache; SELECT `id`,`eid`,`call_type`,`dialing`,`dialing_member`,`incoming`,`incoming_member`,`start_time`,`duration_time`,`duration_minute`,`call_state`,`pub_number`,`outside_type`,`outnumber` FROM talk_call_record_myisam_eid  WHERE ( `eid` = '997' ) AND ( (`start_time` > 1480585500) AND (`start_time` < 1489485000) ) ORDER BY start_time desc,cc_number LIMIT 0,20 ;
   reset query cache; SELECT `id`,`eid`,`call_type`,`dialing`,`dialing_member`,`incoming`,`incoming_member`,`start_time`,`duration_time`,`duration_minute`,`call_state`,`pub_number`,`outside_type`,`outnumber` FROM `talk_call_record_myisam_history` WHERE ( `eid` = '997' ) AND ( (`start_time` > 1480585500) AND (`start_time` < 1489485000) ) ORDER BY start_time desc,cc_number LIMIT 0,20 ;
 | 
   现网库      20 rows in set (2.70 sec)
   分区实时库  20 rows in set (2.55 sec)
   分区历史库  20 rows in set (0.11 sec)
 |
   该语句是搜索通话记录时分页首页语句
 |-
 | style="word-wrap:break-word;word-break:break-all;overflow:hidden;" | 
   reset query cache; SELECT `id`,`eid`,`call_type`,`dialing`,`dialing_member`,`incoming`,`incoming_member`,`start_time`,`duration_time`,`duration_minute`,`call_state`,`pub_number`,`outside_type`,`outnumber` FROM `talk_call_record` WHERE ( `eid` = '997' ) AND ( (`start_time` > 1480585500) AND (`start_time` < 1489485000) ) ORDER BY start_time desc,cc_number LIMIT 100000,20 ;
   reset query cache; SELECT `id`,`eid`,`call_type`,`dialing`,`dialing_member`,`incoming`,`incoming_member`,`start_time`,`duration_time`,`duration_minute`,`call_state`,`pub_number`,`outside_type`,`outnumber` FROM `talk_call_record_myisam_eid` WHERE ( `eid` = '997' ) AND ( (`start_time` > 1480585500) AND (`start_time` < 1489485000) ) ORDER BY start_time desc,cc_number LIMIT 100000,20 ;
   reset query cache; SELECT `id`,`eid`,`call_type`,`dialing`,`dialing_member`,`incoming`,`incoming_member`,`start_time`,`duration_time`,`duration_minute`,`call_state`,`pub_number`,`outside_type`,`outnumber` FROM `talk_call_record_myisam_history` WHERE ( `eid` = '997' ) AND ( (`start_time` > 1480585500) AND (`start_time` < 1489485000) ) ORDER BY start_time desc,cc_number LIMIT 100000,20 ;
 | 
   现网库      20 rows in set (52.53 sec)
   分区实时库  20 rows in set (44.46 sec)
   分区历史库  Empty set (0.35 sec)
 |
   该语句是搜索通话记录时分页大分页语句
 |-
 | style="word-wrap:break-word;word-break:break-all;overflow:hidden;" | 
   reset query cache; select count(t.counts) cnt from (select count(*) counts from talk_call_record where eid=997 and res_token<>'' group by cc_number) t;
   reset query cache; select count(t.counts) cnt from (select count(*) counts from talk_call_record_myisam_eid where eid=997 and res_token<>'' group by cc_number) t;
   reset query cache; select count(t.counts) cnt from (select count(*) counts from talk_call_record_myisam_history where eid=997 and res_token<>'' group by cc_number) t;
 | 
   现网库      1 row in set (29.14 sec)
   分区实时库  1 row in set (26.04 sec)
   分区历史库  1 row in set (0.41 sec)
 |
   该语句是录音管理里获取次数
 |-
 | style="word-wrap:break-word;word-break:break-all;overflow:hidden;" | 
   reset query cache; select max(id) from talk_sync where eid=997;
   reset query cache; select max(id) from talk_sync_myisam_eid where eid=997;
 | 
   现网库      1 row in set (0.09 sec)
   分区实时库  1 row in set (0.00 sec)
   
 |
   该语句是获取同步表最大id
 |}

== mysql压力测试 ==
=== 测试用存储过程 ===
 drop procedure simpletest;
 delimiter //
 create procedure simpletest()
 begin
   reset query cache;
   SELECT sum(duration_time) as stime,sum(duration_minute) as sminute,`outside_type` FROM `talk_call_record` WHERE ( `eid` = '997' ) GROUP BY outside_type;
   reset query cache;
   select id,call_type,dialing,incoming,start_time,duration_time from talk_call_record where eid=997 and (dialing like '%1000%' or incoming like '%1000%') and res_token <> "" order by  start_time desc limit 0,10;
   reset query cache; 
   SELECT `duration_time` FROM `talk_call_record` WHERE ( `res_token` = '45471c6f9db76ed1dcf7ce812b600df31481163525' ) LIMIT 1;
   reset query cache; 
   select count(*) from `talk_call_record` WHERE ( `eid` = '997' ) AND ( (`start_time` > 1480585500) AND (`start_time` < 1489485000) );
   reset query cache; 
   SELECT `id`,`eid`,`call_type`,`dialing`,`dialing_member`,`incoming`,`incoming_member`,`start_time`,`duration_time`,`duration_minute`,`call_state`,`pub_number`,`outside_type`,`outnumber` FROM `talk_call_record` WHERE ( `eid` = '997' ) AND ( (`start_time` > 1480585500) AND (`start_time` < 1489485000) ) ORDER BY start_time desc,cc_number LIMIT 0,20 ;
   reset query cache; 
   SELECT `id`,`eid`,`call_type`,`dialing`,`dialing_member`,`incoming`,`incoming_member`,`start_time`,`duration_time`,`duration_minute`,`call_state`,`pub_number`,`outside_type`,`outnumber` FROM `talk_call_record` WHERE ( `eid` = '997' ) AND ( (`start_time` > 1480585500) AND (`start_time` < 1489485000) ) ORDER BY start_time desc,cc_number LIMIT 100000,20 ;
   reset query cache; 
   select count(t.counts) cnt from (select count(*) counts from talk_call_record where eid=997 and res_token<>'' group by cc_number) t;
   reset query cache; 
   select max(id) from talk_sync where eid=997;
 end //
 delimiter ;

 drop procedure simpletestarea;
 delimiter //
 create procedure simpletestarea()
 begin
   reset query cache;
   SELECT sum(duration_time) as stime,sum(duration_minute) as sminute,`outside_type` FROM `talk_call_record_myisam_eid` WHERE ( `eid` = '997' ) GROUP BY outside_type;
   reset query cache;
   select id,call_type,dialing,incoming,start_time,duration_time from `talk_call_record_myisam_eid` where eid=997 and (dialing like '%1000%' or incoming like '%1000%') and res_token <> "" order by  start_time desc limit 0,10;
   reset query cache; 
   SELECT `duration_time` FROM `talk_call_record_myisam_eid` WHERE ( `res_token` = '45471c6f9db76ed1dcf7ce812b600df31481163525' ) LIMIT 1;
   reset query cache; 
   select count(*) from `talk_call_record_myisam_eid` WHERE ( `eid` = '997' ) AND ( (`start_time` > 1480585500) AND (`start_time` < 1489485000) );
   reset query cache; 
   SELECT `id`,`eid`,`call_type`,`dialing`,`dialing_member`,`incoming`,`incoming_member`,`start_time`,`duration_time`,`duration_minute`,`call_state`,`pub_number`,`outside_type`,`outnumber` FROM `talk_call_record_myisam_eid` WHERE ( `eid` = '997' ) AND ( (`start_time` > 1480585500) AND (`start_time` < 1489485000) ) ORDER BY start_time desc,cc_number LIMIT 0,20 ;
   reset query cache; 
   SELECT `id`,`eid`,`call_type`,`dialing`,`dialing_member`,`incoming`,`incoming_member`,`start_time`,`duration_time`,`duration_minute`,`call_state`,`pub_number`,`outside_type`,`outnumber` FROM `talk_call_record_myisam_eid` WHERE ( `eid` = '997' ) AND ( (`start_time` > 1480585500) AND (`start_time` < 1489485000) ) ORDER BY start_time desc,cc_number LIMIT 100000,20 ;
   reset query cache; 
   select count(distinct cc_number) from talk_call_record_myisam_eid where eid=997 and res_token<>'';
   reset query cache; 
   select max(id) from talk_sync_myisam_eid where eid=997;
 end //
 delimiter ;

=== 测试用性能监控脚本 ===
 #!/bin/bash
 if [ ! -n "$1" ] ;then
   log_file=monitor.log
 else
   log_file=$1
 fi
 i=1
 # second arg is not null then delete the logfile
 if [ "$2" ] ;then
   rm $log_file
 fi
 exec 1>>$log_file
 exec 2>>$log_file
 while true
 do
   time=`date "+%Y-%m-%d %H:%M:%S"`
   cpuuse=`top -b -n2 -p 1 | fgrep "Cpu(s)" | tail -1 | awk -F'id,' -v prefix="$prefix" '{ len=split($1, vs, ","); v=vs[len]; sub("%", "", v); printf  100-v }'`
   memuse=`free -m|grep Mem|awk '{print ($3-$6-$7)/$2*100}'`
   diskuse=`df -h | grep /dev/sda1|awk '{print $5}'|cut -c 1-2`
   mysqlinfo=`top -b -n2 |fgrep mysqld|tail -1`
   mysqlres=`echo "$mysqlinfo"|awk '{print $6}'`
   mysqlcpu=`echo "$mysqlinfo"|awk '{print $9}'`
   mysqlmem=`echo "$mysqlinfo"|awk '{print $10}'`
   rx=`ifconfig eth2 | sed -n "8p" | awk '{print $2}' | cut -c 7-`
   tx=`ifconfig eth2 | sed -n "8p" | awk '{print $6}' | cut -c 7-`
   echo "时间:$time"
   echo "cpu占用:$cpuuse %"
   echo "内存占用:$memuse %"
   echo "磁盘占用:$diskuse"
   echo "mysql Res:$mysqlres"
   echo "mysql cpu:$mysqlcpu %"
   echo "mysql mem:$mysqlmem %"
   sleep 2
 done
 echo "monitor finished"

=== 压力测试 ===

 mysqlslap -uroot -p123456 -c 10 -i 10 --number-of-queries=100 --create-schema talk -q "call simpletest()" --debug-info

=== 测试结果 ===
* 不修改任何配置情况下做压力测试，下面是测试结果
 mysqlslap -uroot -p123456 -c 10  --number-of-queries=3 --create-schema talk -q "call simpletest()" --debug-info
 Benchmark
        Average number of seconds to run all queries: 238.421 seconds
        Minimum number of seconds to run all queries: 238.421 seconds
        Maximum number of seconds to run all queries: 238.421 seconds
        Number of clients running queries: 10
        Average number of queries per client: 0
 User time 0.00, System time 0.02
 Maximum resident set size 1844, Integral resident set size 0
 Non-physical pagefaults 693, Physical pagefaults 29, Swaps 0
 Blocks in 7096 out 0, Messages in 0 out 0, Signals 0
 Voluntary context switches 232, Involuntary context switches 39
 压力测试10个客户端并发，每个客户端执行3次查询，每个客户端执行8个sql（其中包括一个50秒和30秒的慢查询），总的sql个数为240个，执行时间试238秒

* 性能监控
 时间:2017-03-17 19:43:32
 cpu占用:100 %
 内存占用:20.9776 %
 磁盘占用:99
 mysql Res:50m
 mysql cpu:5.0 %
 mysql mem:10.3 %
 mysqlslap 

* 监控mysql show processlist 出现Copying to tmp table，由于select count(t.counts) cnt from (select count(*) counts from talk_call_record where eid=997 and res_token<> group by cc_number) t;这个查询需要生成临时表，如果超过mysql内存限制，会在硬盘上交换数据，这也是为啥磁盘占用99

* 先修改mysql配置
  调整mysql配置
  tmp_table_size           = 64M  //临时表内存大小
  max_heap_table_size      = 64M  //临时表内存大小
  read_buffer_size         = 4M   //读入缓冲
  sort_buffer_size         = 32M  //排序缓冲
  将生成历史表的sql修改为select count(distinct cc_number) from talk_call_record where eid=997 and res_token<>'' ; 花费时间：1 row in set (5.06 sec)

* 对大数据的sql优化
  reset query cache; SELECT `id`,`eid`,`call_type`,`dialing`,`dialing_member`,`incoming`,`incoming_member`,`start_time`,`duration_time`,`duration_minute`,`call_state`,`pub_number`,`outside_type`,`outnumber` FROM `talk_call_record` WHERE ( `eid` = '997' ) AND ( (`start_time` > 1480585500) AND (`start_time` < 1489485000) ) ORDER BY start_time desc,cc_number LIMIT 100000,20 ;
  20 rows in set (14.91 sec)
  加大排序缓冲后，效果明显

* 根据前面的测试，分区分表对性能有一定的优化作用。我们把同样的存储过程修改为针对分区表
  mysqlslap -uroot -p123456 -c 10  --number-of-queries=3 --create-schema talk -q "call simpletestarea()" --debug-info
  Benchmark
        Average number of seconds to run all queries: 220.367 seconds
        Minimum number of seconds to run all queries: 220.367 seconds
        Maximum number of seconds to run all queries: 220.367 seconds
        Number of clients running queries: 10
        Average number of queries per client: 0
  User time 0.00, System time 0.08
  Maximum resident set size 2340, Integral resident set size 0
  Non-physical pagefaults 1025, Physical pagefaults 142, Swaps 0
  Blocks in 24088 out 0, Messages in 0 out 0, Signals 0
  Voluntary context switches 329, Involuntary context switches 150

* 监控性能
  时间:2017-03-19 14:29:57
  cpu占用:100 %
  内存占用:70.8758 %
  磁盘占用:99
  mysql Res:200m
  mysql cpu:67.8 %
  mysql mem:40.8 %
